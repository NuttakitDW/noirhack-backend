{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17808014045028256909,"abi":{"parameters":[{"name":"g","type":{"kind":"field"},"visibility":"private"},{"name":"r","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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gZnnFZieV1RKVhCYeV6B6XlFpWQFgZnnFZieV1RKVhCYeV6B6XlFw2QFmHlegel5xSt7Xoerg9nHYnpe0TBZAWaeV2B6XtExWQFmnldgel7RMVkBZp5XYHpe0TFZAWaeV2B6XtExWQFmnldgel4xMFkBZp5XYHpeMTBZAWaeV2B6XjEwWQFmnldgel4RmKwAM88rMD2veGXP63B1MPtYTM8rApMVYOZ5BabnFROTFWDmeQWm5xUTkxVg5nkFpucVE5MVYOZ5BabnFROTFWDmeQWm5xULkxVg5nkFpucVC5MVYOZ5BabnFQuTFWDmeQWm5xUbkxVg5nkFpucVr+x5Ha4OZh+L6XnFxmQFmHlegel5zYuSFUzMPK+J6XnNi5IVzIuyj52Ynte8KFnBxMzzmpie17woWcHEzPOamJ7XLJSsYGLmeU1Mz2sWSlYwMfO8JqbnNQslK5iYeV4T0/OalZIVTMw8r4npec1X9rwOVwezj8X0vGalZAUTM89rYnpes2GyAsw8r4npec2GyQow87wmpuc1GyYrwMzzmpie12yYrAAzz2tiel6zY7ICzDyviel5zY7JCjDzvCam5zU7JivAzPOamJ7XHJisADPPa2J6XvOVPa/D1cHsYzE9rzkwWQFmntfE9LxmYLICzDyviel5zcBkBZh5XhPT85qByQow87wmpuc1A5MVYOZ5TUzPa05MVoCZ5zUxPa85MVkBZp7XxPS85sRkBZh5XhPT85oLkxVg5nlNTM9rvrLndbg6mH0spuc1FyYrwMzzmpie19yYrAAzz2tiel5zY7ICzDyviel5zY3JCjDzvCam5zU3JStYmHleC9PzWhclK1iYeV7rorxj10XJChZmntfC9LzWRckKFmae18L0vFahZAULM89rYXpe65U9r8PVoexjF6bntQolK1iYeV4L0/NalZIVLMw8r4Xpea1KyQoWZp7XwvS8VqVkBQszz2thel6rYrICzDyvhel5rYbJCjDzvBam57UaJivAzPNamJ7XapisADPPa2F6XqtjsgLMPK+F6XmtV/a8DlcHs4/F9LxWx2QFmHleC9PzWgOTFWDmeS1Mz2sNTFaAmee1MD2vNTBZAWae18L0vNbAZAWYeV4L0/NagckKMPO8FqbntQKTFWDmeS1Mz2sFJivAzPNamJ7XmpisADPPa2F6XuuVPa/D1cHsYzE9rzUxWQFmntfC9LzWwmQFmHleC9PzWguTFWDmeS1Mz2stTFaAmee1MD2vtTBZAWae18L0vNbGZAWYeV4L0/NaG5MVYOZ5LUzPa21MVoCZ57UxPa99UbKCjZnntTE9r311zNWh7GM3pue1L0pWsDHzvDam57ULJSvYmHleG9Pz2oWSFWzMPK+N6XntQskKNmae18b0vHahZAUbM89rM3pejz989/PHT58+/v1vn758//7Xj18+//L4Dx//+P/e//zx/XefPvznjz/+9vn7r/7tr///09u/efvvf/r5y/cffvjt5w9//E3/+nePv/6f","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use shared::utils::{gen_public_key_and_aggregate_key, poseidon_hash};\n\n/// g  : Field - group generator\n/// r  : Field - user-supplied randomness\n/// returns: ( sk , pk )\nfn main(g: Field, r: Field) -> pub (Field, Field) {\n    let sk = poseidon_hash(\n        [r, 0x20644e72e121a029b84045b68180585c2833e84879b9709143e1f593f0000000],\n    );\n    let (_, pk) = gen_public_key_and_aggregate_key(g, sk, 1);\n    (sk, pk)\n}\n\n#[test]\nfn test_main() {\n    let g: Field = 3;\n    let rand: Field = 77;\n\n    let expected_sk = poseidon_hash([\n        rand,\n        0x20644e72e121a029b84045b68180585c2833e84879b9709143e1f593f0000000,\n    ]);\n    let (_, expected_pk) = gen_public_key_and_aggregate_key(g, expected_sk, 1);\n\n    let (sk, pk) = main(g, rand);\n\n    assert(sk == expected_sk);\n    assert(pk == expected_pk);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/gen_elgamal_key_pair/src/main.nr"},"63":{"source":"pub mod matrix;\n\npub fn pow(base: Field, exponent: Field) -> Field {\n    let bits: [u1; 254] = exponent.to_le_bits();\n    let mut result = 1;\n    let mut power = base;\n\n    for i in 0..254 {\n        let bit = bits[i];\n        let term = if bit == 1 { power } else { 1 };\n        result *= term;\n        power *= power;\n    }\n    result\n}\n\npub fn enforce_permutation<let N: u32>(mat: [[Field; N]; N]) {\n    for i in 0..N {\n        for j in 0..N {\n            let c = mat[i][j];\n            assert(c * (c - 1) == 0);\n        }\n    }\n\n    for i in 0..N {\n        let mut row_sum = 0;\n        for j in 0..N {\n            row_sum += mat[i][j];\n        }\n        assert(row_sum == 1);\n    }\n\n    for j in 0..N {\n        let mut col_sum = 0;\n        for i in 0..N {\n            col_sum += mat[i][j];\n        }\n        assert(col_sum == 1);\n    }\n}\n\n#[test]\nfn test_pow() {\n    // 10^9  where exponent is passed as Field\n    let exp_field: Field = 9;\n    let r = pow(10, exp_field);\n\n    let mut exp: Field = 1;\n    for _ in 0..9 {\n        exp *= 10;\n    }\n    assert(r == exp);\n\n    // max exponent\n    let base: Field = 7;\n    let e: Field = (-1 as i64) as Field;\n    let r: Field = pow(base, e);\n    let r_next_left = pow(base, e + 1);\n    let r_next_right = r * base;\n    assert(r_next_left == r_next_right);\n}\n\n#[test]\nfn test_pow_max_exponent() {\n    let base: Field = 7;\n\n    let e: Field = (-1 as i64) as Field;\n\n    let r: Field = pow(base, e);\n\n    let r_next_left = pow(base, e + 1);\n    let r_next_right = r * base;\n\n    assert(r_next_left == r_next_right);\n}\n\n#[test]\nfn test_enforce_perm_u10_perm_4_ok() {\n    let p: [[Field; 4]; 4] = [[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]];\n    enforce_permutation(p);\n}\n\n#[test(should_fail)]\nfn test_enforce_perm_u10_perm_5_bad() {\n    let bad: [[Field; 5]; 5] =\n        [[1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 1, 0, 0, 0]];\n    enforce_permutation(bad);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/shared/src/algebra/mod.nr"},"67":{"source":"use crate::algebra::pow;\nuse std::hash::poseidon2::Poseidon2;\n\npub fn gen_public_key_and_aggregate_key(\n    generator: Field,\n    sk: Field,\n    old_aggk: Field,\n) -> (Field, Field) {\n    let pk = pow(generator, sk);\n    let new_aggk = old_aggk * pk;\n    (pk, new_aggk)\n}\n\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\n#[test]\nfn test_onion_aggregation() {\n    let generator: Field = 3; // Generator value\n    let sk1: Field = 22.into(); // Player 1's secret key\n    let sk2: Field = 33.into(); // Player 2's secret key\n    let sk3: Field = 44.into(); // Player 3's secret key\n\n    let old_aggk: Field = 1.into(); // Starting aggregated key\n\n    // Player 1 generates their public key and aggregates\n    let (_, aggk1) = gen_public_key_and_aggregate_key(generator, sk1, old_aggk);\n    // println(f\"Player 1 public key: {pk1}, Aggregated key: {aggk1}\");\n\n    // Player 2 generates their public key and aggregates with the previous one\n    let (_, aggk2) = gen_public_key_and_aggregate_key(generator, sk2, aggk1);\n    // println(f\"Player 2 public key: {pk2}, Aggregated key: {aggk2}\");\n\n    // Player 3 generates their public key and aggregates with the previous one\n    let (_, aggk3) = gen_public_key_and_aggregate_key(generator, sk3, aggk2);\n    // println(f\"Player 3 public key: {pk3}, Aggregated key: {aggk3}\");\n\n    // Final aggregated key after all players\n    let expected_aggk: Field = pow(generator, sk1) * pow(generator, sk2) * pow(generator, sk3);\n    assert(aggk3 == expected_aggk, \"Final aggregated key does not match expected value.\");\n\n    // Verify the correctness of the aggregation\n    // let debug_final = f\"Final aggregated key: {aggk3}, Expected aggregated key: {expected_aggk}\";\n    // println(debug_final);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/shared/src/utils.nr"}},"names":["main"],"brillig_names":["directive_to_radix"]}