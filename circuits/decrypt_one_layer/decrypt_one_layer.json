{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":12188211793319361182,"abi":{"parameters":[{"name":"g","type":{"kind":"field"},"visibility":"private"},{"name":"card","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"sk","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"1Z3brlxFlkX/xc887LitiOBXWq2SAVOyZNkITEstVP/eCY2LKuXWCpWoSo3xhvGBMxX7MiNm5hzrlzffvfvm57/+5f3H7z/99Obr//rlzYdP3779/P7Tx8effnlz/favfvrh7cdf//TT57c/fn7zdS/lqzfvPn73+KdW/vbVm+/ff3j35ut4/OPTj5arx+8/W64Rf/xwv/nhPb78aOl//GS7+cm64svP1rX+0FDW3/77qzfFKLoaRTej6G4UPYyiwyh6GkUvo+itNBenJSo9sShNsShdsShtsSh9sSiNsSidsSitsSi9sSq9sTrPi0pvrEpvrEpvrEpvrEpvrEpvrEpvrEpvbEpvbEpvbM4wVemNTemNTemNTemNTemNTemNTemNXemNXemNXemN3flJo9Ibu9Ibu9Ibu9Ibu9Ibu9Ibh9Ibh9Ibh9Ibh9Ibh9Ibh9Ibh9Ibh9Ibh9Ibh9IbQ+mNofTGUHpjKL0xlN4Yzu+oKr0xlN4YSm8MpTdOpTdOpTdOpTdOpTdOpTdOpTdOZ4FD6Y1T6Y1T6Y1L6Y1L6Y1L6Y1L6Y1L6Y1L6Y1L6Y3L2W5UeuNSeuNWeuNWeuNWeuNWeuNWeuNWeuNWeuNWeuN2Vv+l3X9n+f9ytv8vZ/3/cvb/L6VBPn6TU7YTAXA5GQCXEwJwOV3SishxuqQUkiOl5EgxOVJOjhSUIyXlSFE5TlZOccJyipOWU5y4nOLk5RQnMKc4iTnFicwpTmZOcUJzipOaU5zYnOLk5hQnOKc4yTnFic4pTnZOccJzipOeU5z4nOLk5xQnQKc4CTrFidApToZOcUJ0ipOiU5wYneLk6BQnSKc4STrFidIpTpZOccJ0ipOmU5w4neLk6RQnUKc4iTrFidQpTqZOcUJ1ipOqU5xYneLk6hQnWKc4yTrFidYpTrZOccJ1ipOuU5x4neLk6xQnYKc4CTvFidgpTsZOcUJ2ipOyU5yYneLk7BQnaKc4STvFidopTtZOccJ2ipO2U5y4neLk7RQncKc4iTvFidwpTuZOcUJ3ipO6U5zYneLk7hQneKc4yTvFid4pTvZOdbJ3qpO9U53snepk79RL6ZLVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3qpO9U53snepk71Qne6c62TvVyd6pTvZOdbJ3KpW90+qsv/9sq2s/yYa65Ek21CVbveLvsuvzTQJ1yYNsKnvnJBvqkod7m8reOa021CVPqw11ydNqQ13ytNpYl8xX2+mSVPbOabWxLpmuNpW980+r3eaTbKxL5rKxLpnfJE6XpLJ3TjcJ1iVz2QaXvJGNdclcNtYl80fS6ZJU9s5hT0Jl75xkO8+SVPbO6d42uOTNajvPklT2zsFuqOydk2ynS1LZOwfZVPbO4U1CZe+cZDtdksreOd3bTpeksndOq+1MXKnsndNqGxLXZ3Onsndy2Y3K3slvkkZl75xkK12yUdk7J9lKl2xU9s7p3la6ZKOyd06rrXTJRmXvHGRT2TuHm4TK3jnJNrjkzU1icMkb2QaXvJGt/FyyUdk7p0fS6ZJU9s7pJnG6JJW9c5Kt/PZOo7J3Do8klb1zkm1wyefTDZW9c5LtPEtS2Tune1v5HddGZe8cVpvK3jnYDZW9c5LtdEkqe+ck2+CSNzeJ8yxJZe+cZCu/vdOo7J3TI+l0SSp753CTUNk7J9nOxJXK3jnJxrpk/kg6P5eksncOpxsqe+ck23mWpLJ3Dvc2lb1zWG0qe+e02k6XpLJ3TrKdLkll75xkO12Sy97JZTtdksveSe9tBXvn+QXIZe/ksp2Jq5O90xTsnZubxJm4Ktg7N7KdiSuXvZM/kk6XdLJ3mpO907jsnVy28yzJZe/kj6TzLKlg7zyfbhTsnRvZzrOkk73TnOydxmXv5Kvt7Es62TvNyd5pTvZOc7J3mpO905zsneZk7zQne6c52TvNyd5pTvZOc7J3mpO90xTsnWe74bJ3ctlOl+SydzLZncveyW6SzmXv5LKViWtXsHduZGNdMn8klS7ZneydzmXv5LKViWvnsnfSe5vL3klX28ne6Qr2zs1qK8+S3cne6U72Tneyd7qTvdOd7J3uZO90J3unO9k73cne6U72Tneyd7qTvdOd7J3uZO90BXvn5gXodEkueye9SbjsnVy28yzJZe/ksp0uyWXv5Pe20yW57J18tZ2Jq5O90xXsnefV5rJ38tV2uiSXvZOvttMlneyd7mTvdC57J19t51mSy95JZXPZO+lN4mTvdAV75/lNomDv3Mh2uqSTvdMV7J2bF6DyO66dy97JbxLnWVLB3nl+kyjYOzeynS7pZO90BXvnZrWdLulk73Qne6c72Tvdyd7pTvZOd7J3upO9053sne5k73Qne6c72Tvdyd7pTvZOd7J3uoK98/wC5LJ3ctnO77g62Ttdwd65uUmcTRAne6c72Tvdyd7pTvZOV7B3nm8SBXvnRrbzLMll7+SysS6ZP5LOs6SCvfN8ulGwd25kO8+STvbOULB3nlZ7cNk7+WorP5ccXPZOvtpYl8xXW+mSQ8HeedpKDQV750a28iw5nOyd4WTvDC57J5ftdEkne2c42TvDyd4ZTvbOcLJ3hoK9c/MmMTRBnmUr2Ds3sp1nSS57J19tp0s62TuDy97JV1uZuA4ne2co2Ds3q+08S3LZO+nGlcveyWUrv70zuOydXLbTJbnsnVy20yWd7J3hZO8MJ3tnONk7w8neGQr2zrO5c9k7uWysS+Y3ifMs6WTvDC57J5ftdEkueye9t7nsnfQFyGXv5LKdZ0kueyeXjXXJ/CZxfi7pZO8MJ3tnONk7w8neGU72znCyd4aTvTOc7J2hYO88vwC57J1ctvPbO1z2Ti5byXEdXPZOKtvJ3hlO9s7gsnfSR5LL3sllG1zyeU/CZe/ksp2JK5e9k9/bTpfksndS2Vz2TnqTcNk7uWzn55Jc9k4u2+CSN7KdZ0kueyd/JJ0uyWXvpHsSLnsnla1g79zIdrqkk70znOyd4WTvDCd7ZzjZO8PJ3hlO9s5wsnfCyd4JJ3snnOydcLJ34sK6ZL7aSpcMBXvnZrWVZ8ngsnfy1Xa6pIK983RMCAV750a28nPJcLJ3wsneCSd7J7jsnVy28juuwWXv5I+k0yWd7J3gsndy2c6zpJO9E072TjjZO+Fk74STvRNO9k442TuhYO88rzaXvZOvttMlneydULB3no8JCvbOjWzlt3fCyd4JJ3snuOydVLaTvRNO9k442TvhZO+Ek70TTvZOONk74WTvhJO9E072TjjZO+Fk74STvRNO9k442TvhZO+Ek70TTvZOONk74WTvhJO9E072TjjZO+Fk74SCvXOz2s6zJJe9k6+2M3FVsHduVtvpkk72TjjZO+Fk74STvRNO9k442TvhZO+Ek70TTvZOONk74WTvhJO9E072TjjZO+Fk74STvRNO9k442TuhYO/c3CROl1Swd25kO8+SXPZO+khy2Tu5bINLPp9uuOydXLbzLMll7+T3ttMlueydTPbksneym2Q62TvTyd6ZXPZOLlvpktPJ3plO9s50snemgr1zYzdOl+Syd9KbhMveyWU7XZLL3sllO12Sy97J723ld1ynk70zneyd6WTvTCd7ZzrZO9PJ3plO9s50snemk70zneyd6WTvTCd7ZzrZO9PJ3plO9s5UsHeeN65c9k4uG+uS+U3idEkueye/SZxnSQV750a2M3HlsnfSR9LJ3pkK9s7znkTB3rmRjXXJXLbTJZ3sncll7+Sr7XRJLnsnlc1l76Q3CZe9k8t2niW57J1ctsElb2QrmyCTy97JH0mnS3LZO/lN4nRJBXvnRrayCTK57J30kXSyd6aCvXNzkzhdUsHeuZHtTFy57J38kXR+Lulk70wne2dy2Tu5bOdZksveyR9JZ+LqZO9MLnsnl+389g6XvZPe21z2TvoC5LJ3ctnOsySXvZPLxrpk+iZRsHduZDtd0snemQr2zs1qO11Swd55Xm0ueydfbee3d5zsnalg7zxvpRTsnRvZzs8lneydqWDv3LxJlPMlF5e9k8tWuuRysncWl72Tr7bSJReXvZPLVrrkcrJ3loK9c/Mmcbokl72Ty3a6pJO9s7jsnXy1DS55s9rKzyWXgr1zs9pOl+Syd9KtFJe9k8rmsnfSm4TL3sllK7+9s7jsnVy2wSVvZDvPklz2Tv5IOl1Swd65uUmcLqlg79zIVn57Z3HZO+kjyWXv5LKdLsll7+SylU2Q5WTvLC57J38kld/eWVz2TpqTcNk7uWxn4spl7+T3tsElb1bbmbgq2DvPdsNl7+SynS7JZe+ksrnsnfQm4bJ3ctnOxNXJ3llc9k7+SDpdksveSfckXPZOLtv57R0ueye9t53sneVk7ywne2c52TvLyd5ZTvbOcrJ3lpO9s5zsneVk7ywne2c52TvLyd5ZTvbOcrJ3lpO9s5zsneVk7ywne2c52TtLwd55Xm0ueydfbadLctk7uWynS3LZO7lsp0ty2Tu5bKdLOtk7S8HeeX4Bctk7uWxn4upk7ywne2c52TuLy97JZTsTVy57J38klS65Feydp5tkc9k7uWzlWXJz2Tu5bKxL5o+k8iy5ueyd7HSzueydXLbyLLm57J303nayd7aTvbOd7J3tZO9sJ3tnO9k7W8Heed5Kcdk7uWzlWXJz2TupbC57J32TcNk7uWynS3LZO/m97XRJLnsnX22nS3LZO7lsp0ty2TupbAV75/lNomDv3Mh2uqSTvbMV7J2b1Xa6pIK9c7PaSkLd5rJ3UnPnsndS2Vz2TnqTcNk7uWynS3LZO7lsp0s62Tvbyd7ZTvbOdrJ3tpO9sxXsnec3iYK9cyPb6ZJc9k5+bztd0sne2U72zuayd/LVdn57x8ne2U72znayd7aTvbOd7J3tZO9sJ3tnO9k728ne2U72znayd7aTvbOd7J3tZO9sJ3tnO9k728ne2Qr2zs1N4nRJBXvnRrbzc0kueyd9JJ3sne1k72wne2dz2Tu5bOdZksveyR9JZ+LqZO9sLnsnla1g79zIdrokl72Tr7YzcVWwd25W23mWVLB3blbb6ZJc9k66leKydzLZ5eLCd7K75KFb6ZMP3crj5EO38jz50G2wyjvdyhPlQ7fySPnQrXTLh26lXT50S/1SgeG50638jPKhW/lVnodu5cnyoVvql1wWz0G38oPKh27lJ5UP3cov9Dx0K7/RUy4FkOfmPlEQee50S8+XXCbPQTfWLw/PpTKLfehWhrEP3UrG60O38kPLh26pXyrQPDfvQQWb50639HzppPM8dGP9Mn+fcPk8B91Sv3QSeh66pXmsk9Hz+KXSzy+dlJ7HL5WeLxWcnjvdBr+80y3NY7monsNzKfVLLqwn359waT25bieu5/GbpH7pBPY8fpP0fKlA9tz4DpfZc9At9Usntefxm6R+yeX25LoV4J473VK/5KJ7Dust9UsnvOehW+qXXHzP4T6R+iUX4HO4T6R5rBPh89At/fySC/HJn0suxeegW+qXXI7PQbf0+7FOks9Dt/T7sVyWT66bC/PJ7xMuzeegW/r5pZPn89CN9cvDcyn9fiwX6XO4T6R+qYD63OmWni+5WJ/8uXRyfR66pX7JJfscdGP98qBber7kwn0Oz6U0j1XgfW4+31HwfZ51Fy7f56Db6ZdFwfe5W29nHvv4rdL1dp4vC5fvc1hvp18WBd/nbr2deWxR8H1u1pvL9zmst9QvpXyfouD73K231C8VfJ+79Zb6JZfvc1hvqV8q+D43683l+xzWW+qXXL7PYb2lfinl+xQp36dw+T6H9Zb6pZTvUxR8n5v15vJ9Dust9Usp36dI+T6Fy/c5rLfUL6V8n6Lg+9ytt9QvuXyffL2lfJ+i4PvcrbfULxV8n7v1lvoll+9zWG+pX0r5PoXL98nXW8r3KVK+T5HyfYqU71OkfJ8i5fsUKd+nSPk+Bcv36df1RXe/6rPuP++Xe/1dTL1y3e1qX8SU+Y/Cf9Pyb2D2/Ata6ty//2zd7VlLAWmpoGvUQOvSQVoG6BoFaF0mSMsCXaPNWZcJeu/OwrlGs4LWBfTenR10jQZoXUDv3TlB12iB1gX03l0X5xot0H53gd67q4GuEWi/u0Dv3RWgawTa7y7Qe3eBcoYN2u9u0Ht3g3KGDdrvbtB7d4Nyhg3a727Qe3eDcobN2e/Wi/PerRcnZ6gXZ79bL857t14ddI04+916cd679eLkDPXi7HfrBXrvFk7OUAtnv1sL6L1bODlDLR20LqD3buHkDLVw9ru1gN67hZMz1Ara71bQe7dycoZaQfvdCnrvVk7OUCtov1tB793KyRlqBe13G+i920A5QwPtdxvovds66BqB9rsN9N5toJyhgfa7DfTe7aCcoYP2ux303u2gnKF30LqA3rsdlDN00H63g967HZQzDNB+d4DeuwOUMwzQfneA3rsDlDMM0H53gN67A5QzDNB+F9RXqwHKGQK03wX11epr+2qHawTa74L6ajVAOUOA9rugvlqdoJxhgva7oL5anaCc4bV9tcO6gN67E5QzTNB+F9RXqxOUMyzQfhfUV6sLlDMs0H4X1FerC5QzLNB+F9RXqwuUMyzQfhfUV6sblDNs0H4X1Ferr+2rHa4RaL8L6qvVDcoZNmi/C+qrtYuTM7SLs99toL5auzg5Q7s4+90G6qu1i5MztIuz322gvlq7ODlDK5z9bgP11Vrh5AytcPa7DdRXa4WTM7TC2e82UF+tFU7O0Apovwvqq7XKyRlaBe13QX219tq+2uEagfa7oL5aq5ycoVXQfhfUV2sNlDM00H4X1FdrDZQzvLavdlgX0Hu3gXKGBtrvgvpqrYFyhg7a74L6aq2DcoYO2u+C+mqtg3KGDtrvgvpqrYNyhg7a74L6am2AcoYB2u+C+mrttX21wzUC7XdBfbU2QDnDAO13QX21FqCcATRfrYH6ai1AOQNovloD9dVagHIG0Hy1BuqrtQDlDKD5ag3UV2sTlDOA5qs1UF+tTVDOAJqv1kB9tTZBOQNovloD9dXaAuUMoPlqDdRXa6/tqx2uEWi/C+qrtQXKGUDz1Rqor9Y2KGcAzVdroL5a26CcATRfrYH6am2DcgbQfLUG6qu1zckZOmi+Wgf11frFyRk6aL5avzjv3X5xcoYOmq/WQX21fnFyhg6ar9ZBfbVeODlDB81X66C+Wn9tX+1wjTj73Q7qq/XCyRk6aL5aB/XVeuXkDB00X62D+mq9cnKGDpqv1kF9tV45OUMHzVfroL5ar6CcATRfrYP6ar2BcgbQfLUO6qv1BsoZQPPVOqiv1hsoZwDNV+ugvlrvoJwBNF+tg/pq/bV9tcM1Au13QX213kE5A2i+Wgf11foA5Qyg+Wod1FfrA5QzgOardVBfrQ9QzgCar9ZBfbU+QDkDaL5aB/XVeoByBtB8tQ7qq/UA5Qyg+Wod1FfrAcoZQPPVOqiv1icoZwDNV+ugvlp/bV/tcI1A+11QX61PUM4Amq/WQX21vkA5A2i+Wgf11foC5Qyg+Wod1FfrC5QzgOardVBfrS9QzgCar9ZBfbW+QTkDaL5aB/XV+gblDKD5ah3UV+sblDOA5qsNUF9tXJycYYDmqw1QX21cHXSNOPvdAeqrjYuTMwzQfLUB6quNwskZBmi+2gD11Ubh5AwDNF9tgPpqo3ByhgGarzZAfbVRODnDAM1XG6C+2qicnGGA5qsNUF9tVE7OMEDz1QaorzYqJ2cYoPlqA9RXGw2UM4Dmqw1QX228tq92uEag/S6orzYaKGcAzVcboL7a6KCcATRfbYD6aqODcgbQfLUB6quNDsoZQPPVBqivNjooZwDNVxugvtoYoJwBNF9tgPpqY4ByBtB8tQHqq40ByhlA89UGqK82ApQzgOarDVBfbby2r3a4RqD9LqivNgKUM4Dmqw1QX21MUM4Amq82QH21MUE5A2i+2gD11cYE5Qyg+WoD1FcbE5QzgOarDVBfbSxQzgCarzZAfbWxQDkDaL7aAPXVxgLlDKD5agPUVxsblDOA5qsNUF9tvLavdrhGoP0uqK82NihnAM1XG6C+WlycnCFA89UC1FeLi5MzxMXZ7waorxYXJ2cI0Hy1APXV4uLkDAGarxagvloUTs4QoPlqAeqrReHkDAGarxagvloUTs4QoPlqAeqrReXkDAGarxagvlq8tq92uEag/S6orxaVkzMEaL5agPpq0UA5A2i+WoD6atFAOQNovlqA+mrRQDkDaL5agPpq0UA5A2i+WoD6atFBOQNovlqA+mrRQTkDaL5agPpq0UE5A2i+WoD6ajFAOQNovlqA+mrx2r7a4RqB9rugvloMUM4Amq8WoL5aBChnAM1XC1BfLQKUM4DmqwWorxYByhlA89UC1FeLAOUMoPlqAeqrxQTlDKD5agHqq8UE5Qyg+WoB6qvFBOUMoPlqAeqrxQLlDKD5agHqq8Vr+2qHawTa74L6arFAOQNovlqA+mqxQTkDaL5agPpqsUE5A2i+WoD6arFBOQNovlqA+mqxOTnDBM1Xm6C+2rw4OcMEzVebF+e9Oy9OzjBB89UmqK82L07OMEHz1SaorzYLJ2eYoPlqE9RXm6/tqx2uEWe/O0F9tVk4OcMEzVeboL7arJycYYLmq01QX21WTs4wQfPVJqivNisnZ5ig+WoT1FebFZQzgOarTVBfbTZQzgCarzZBfbXZQDkDaL7aBPXVZgPlDKD5ahPUV5sdlDOA5qtNUF9tvravdrhGoP0uqK82OyhnAM1Xm6C+2hygnAE0X22C+mpzgHIG0Hy1CeqrzQHKGUDz1SaorzYHKGcAzVeboL7aDFDOAJqvNkF9tRmgnAE0X22C+mozQDkDaL7aBPXV5gTlDKD5ahPUV5uv7asdrhFovwvqq80JyhlA89UmqK82FyhnAM1Xm6C+2lygnAE0X22C+mpzgXIG0Hy1CeqrzQXKGUDz1SaorzY3KGcAzVeboL7a3KCcATRfbYL6anODcgbQfLUF6quti5MzLNB8tQXqq62rg64RZ7+7QH21dXFyhgWar7ZAfbVVODnDAs1XW6C+2iqcnGGB5qstUF9tFU7OsEDz1Raor7YKJ2dYoPlqC9RXW5WTMyzQfLUF6qutyskZFmi+2gL11Vbl5AwLNF9tgfpqq4FyBtB8tQXqq63X9tUO1wi03wX11VYD5Qyg+WoL1FdbHZQzgOarLVBfbXVQzgCar7ZAfbXVQTkDaL7aAvXVVgflDKD5agvUV1sDlDOA5qstUF9tDVDOAJqvtkB9tTVAOQNovtoC9dVWgHIG0Hy1Beqrrdf21Q7XCLTfBfXVVoByBtB8tQXqq60JyhlA89UWqK+2JihnAM1XW6C+2pqgnAE0X22B+mprgnIG0Hy1BeqrrQXKGUDz1Raor7YWKGcAzVdboL7aWqCcATRfbYH6amuDcgbQfLUF6qut1/bVDtcItN8F9dXWBuUMoPlqC9RX2xcnZ9ig+Wob1FfbFydn2Bdnv7tBfbV9cXKGDZqvtkF9tX1xcoYNmq+2QX21XTg5wwbNV9ugvtounJxhg+arbVBfbf/5vlrt1xct9VcBf2j5/1+w/8O/4M83y06/4E+/9lqdX35B69fzL6j/zl8w5j/9gscfvvnx/YcP7//6lw+fvn37+f2njz89/tPHv/6ftz++f/vNh3e///H7nz9++w9/+/l/f/jyN1/++x9+/PTtu+9+/vHdr/+n3/7u8b//Pw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use shared::elgamal::{calculate_decrypt_component, decrypt, encrypt};\nuse shared::utils::gen_public_key_and_aggregate_key;\n\n/// g            : Field            - generator\n/// card         : [Field; 2]       - a single card `[c1, c2]`\n/// sk           : Field            - one share of the secret key\nfn main(g: Field, card: pub [Field; 2], sk: Field) -> pub ([Field; 2], Field) {\n    let (_, decrypted_card) = decrypt(g, card, sk);\n    let decrypt_component = calculate_decrypt_component(card[0], sk);\n    (decrypted_card, decrypt_component)\n}\n\n#[test]\nfn test_main() {\n    let g: Field = 3;\n    let sk: Field = 22;\n    let m: Field = 42;\n    let r: Field = 77;\n\n    let (_, pk) = gen_public_key_and_aggregate_key(g, sk, 1);\n    let card = encrypt(g, pk, [1, m], r);\n\n    let (decrypted, decrypt_component) = main(g, card, sk);\n\n    assert(decrypted[1] == m);\n    assert(decrypt_component == calculate_decrypt_component(card[0], sk));\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/decrypt_one_layer/src/main.nr"},"63":{"source":"pub mod matrix;\n\npub fn pow(base: Field, exponent: Field) -> Field {\n    let bits: [u1; 254] = exponent.to_le_bits();\n    let mut result = 1;\n    let mut power = base;\n\n    for i in 0..254 {\n        let bit = bits[i];\n        let term = if bit == 1 { power } else { 1 };\n        result *= term;\n        power *= power;\n    }\n    result\n}\n\npub fn enforce_permutation<let N: u32>(mat: [[Field; N]; N]) {\n    for i in 0..N {\n        for j in 0..N {\n            let c = mat[i][j];\n            assert(c * (c - 1) == 0);\n        }\n    }\n\n    for i in 0..N {\n        let mut row_sum = 0;\n        for j in 0..N {\n            row_sum += mat[i][j];\n        }\n        assert(row_sum == 1);\n    }\n\n    for j in 0..N {\n        let mut col_sum = 0;\n        for i in 0..N {\n            col_sum += mat[i][j];\n        }\n        assert(col_sum == 1);\n    }\n}\n\n#[test]\nfn test_pow() {\n    // 10^9  where exponent is passed as Field\n    let exp_field: Field = 9;\n    let r = pow(10, exp_field);\n\n    let mut exp: Field = 1;\n    for _ in 0..9 {\n        exp *= 10;\n    }\n    assert(r == exp);\n\n    // max exponent\n    let base: Field = 7;\n    let e: Field = (-1 as i64) as Field;\n    let r: Field = pow(base, e);\n    let r_next_left = pow(base, e + 1);\n    let r_next_right = r * base;\n    assert(r_next_left == r_next_right);\n}\n\n#[test]\nfn test_pow_max_exponent() {\n    let base: Field = 7;\n\n    let e: Field = (-1 as i64) as Field;\n\n    let r: Field = pow(base, e);\n\n    let r_next_left = pow(base, e + 1);\n    let r_next_right = r * base;\n\n    assert(r_next_left == r_next_right);\n}\n\n#[test]\nfn test_enforce_perm_u10_perm_4_ok() {\n    let p: [[Field; 4]; 4] = [[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]];\n    enforce_permutation(p);\n}\n\n#[test(should_fail)]\nfn test_enforce_perm_u10_perm_5_bad() {\n    let bad: [[Field; 5]; 5] =\n        [[1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 1, 0, 0, 0]];\n    enforce_permutation(bad);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/shared/src/algebra/mod.nr"},"64":{"source":"use crate::algebra::pow;\nuse crate::utils::gen_public_key_and_aggregate_key;\n\n/// Minimal ElGamal encryption for one card using.\n///\n/// msg   = [c1, c2]   (fresh card uses [1, m]), public input\n/// g     = generator  (Field, e.g. 3)\n/// pk    = public key h = g^sk, public input\n/// rand  = y in [0,255] (u256 nonce)\n/// ret   = [c1, c2]   ciphertext\npub fn encrypt(g: Field, pk: Field, msg: [Field; 2], rand: Field) -> [Field; 2] {\n    let g_pow_y: Field = pow(g, rand);\n    let h_pow_y: Field = pow(pk, rand);\n\n    let c1: Field = msg[0] * g_pow_y;\n    assert(c1 != 0, \"C1 must be non-zero\");\n\n    let c2: Field = msg[1] * h_pow_y;\n    [c1, c2]\n}\n\n/// Minimal ElGamal partial-decryption for one card.\n///\n/// g           = generator  (Field, e.g. 3)\n/// ciphertext  = [c1, c2]   ciphertext input, public input\n/// sk          = secret key x (Field, u256)\n/// ret         = (pk, [c1, m]) where pk = g^x and m = c2 / c1^x\npub fn decrypt(g: Field, ciphertext: [Field; 2], sk: Field) -> (Field, [Field; 2]) {\n    // pk  = g^sk\n    let pk: Field = pow(g, sk);\n\n    // c1^sk\n    let card_exp: Field = pow(ciphertext[0], sk);\n\n    // message[0] stays as c1\n    let m1: Field = ciphertext[0];\n\n    // message[1] = c2 / c1^sk\n    let m2: Field = ciphertext[1] / card_exp;\n\n    // equality constraint   m2 * card_exp == c2\n    assert(m2 * card_exp == ciphertext[1]);\n\n    (pk, [m1, m2])\n}\n\n/// Computes a decryption component for ElGamal.\n///\n/// c1  = g^r (first part of the ciphertext)\n/// sk  = one share of the secret key (Field)\n///\n/// ret = c1^sk, which contributes to recovering m = c2 / c1^sk\npub fn calculate_decrypt_component(c1: Field, sk: Field) -> Field {\n    pow(c1, sk)\n}\n\n#[test]\nfn test_encrypt_single_card() {\n    let g: Field = 3;\n    let sk: Field = 17;\n    let h: Field = pow(g, sk); // public key h = g^sk\n\n    let plain: [Field; 2] = [1, 42];\n    let rand: Field = 77.into(); // fresh nonce\n\n    let ct = encrypt(g, h, plain, rand);\n\n    // C1 should equal g^rand\n    assert(ct[0] == pow(g, rand));\n\n    // C2 should equal 42 * h^rand\n    let expected_c2 = 42 * pow(h, rand);\n    assert(ct[1] == expected_c2);\n}\n\n#[test]\nfn test_encrypt_then_decrypt_once() {\n    let g: Field = 3;\n\n    // secret key and derived public key\n    let sk: Field = 22.into();\n    let pk: Field = pow(g, sk);\n\n    // plaintext card  (fresh card => [1, m])\n    let plain: [Field; 2] = [1, 99];\n\n    // encrypt with random y\n    let rand: Field = 77.into();\n    let ct = encrypt(g, pk, plain, rand);\n\n    // decrypt\n    let (recovered_pk, msg) = decrypt(g, ct, sk);\n\n    // pk round-trip check\n    assert(recovered_pk == pk);\n\n    // message limb (index 1) should equal original m = 99\n    assert(msg[1] == plain[1]);\n\n    // the first limb is still c1 = g^rand, so this holds instead:\n    assert(msg[0] == ct[0]);\n}\n\n#[test]\npub fn test_2_layered_onion_encryption_decryption() {\n    // Generator value and secret keys\n    let g: Field = 3; // Example generator\n    let sk1: Field = 22.into(); // Player 1's secret key\n    let sk2: Field = 33.into(); // Player 2's secret key\n\n    // Initial aggregated key (starts with 1)\n    let old_aggk: Field = 1.into();\n\n    // Generate public keys and aggregated key using the new function\n    let (pk1, agg_pk1) = gen_public_key_and_aggregate_key(g, sk1, old_aggk); // Player 1's public key and aggregated key\n    let (pk2, agg_pk2) = gen_public_key_and_aggregate_key(g, sk2, agg_pk1); // Player 2's public key and aggregated key\n\n    // At this point, agg_pk2 is the final aggregated public key\n    let agg_pk: Field = agg_pk2; // The final aggregated public key after both players\n\n    // Initial message (fresh card with 1 and message m)\n    let m: Field = 99.into();\n    let plain: [Field; 2] = [1.into(), m]; // Initial message is [1, m]\n\n    // Player 1 encrypts the message using the aggregate public key\n    let rand1: Field = 77.into(); // Random value for Player 1\n    let ct1 = encrypt(g, agg_pk, plain, rand1);\n    // println(f\"Player 1 encryption (ct1): {ct1}\");\n\n    // Player 2 encrypts the ciphertext (ct1) using the aggregate public key\n    let rand2: Field = 88.into(); // Random value for Player 2\n    let ct2 = encrypt(g, agg_pk, ct1, rand2);\n    // println(f\"Player 2 encryption (ct2): {ct2}\");\n\n    // Player 2 decrypts the ciphertext (ct2) using their secret key sk2\n    let (recovered_pk2, msg2) = decrypt(g, ct2, sk2);\n    // println(f\"Player 2 decryption (msg2): {msg2}\");\n    // println(f\"Recovered public key (Player 2): {recovered_pk2}\");\n\n    // Player 1 decrypts the ciphertext (msg2) using their secret key sk1 to get back the original message\n    let (recovered_pk1, msg3) = decrypt(g, msg2, sk1);\n    // println(f\"Player 1 decryption (msg3): {msg3}\");\n    // println(f\"Recovered public key (Player 1): {recovered_pk1}\");\n\n    assert(recovered_pk2 == pk2, \"Decrypted public key does not match original public key\");\n    assert(recovered_pk1 == pk1, \"Decrypted public key does not match original public key\");\n\n    // Verifying that the final decrypted message matches the original plaintext\n    assert(msg3[1] == m, \"Decrypted message does not match original message\");\n}\n\n#[test]\npub fn test_3_layered_onion_encryption_decryption() {\n    // Generator value and secret keys\n    let g: Field = 3; // Example generator\n    let sk1: Field = 22.into(); // Player 1's secret key\n    let sk2: Field = 33.into(); // Player 2's secret key\n    let sk3: Field = 44.into(); // Player 3's secret key\n\n    // Initial aggregated key (starts with 1)\n    let old_aggk: Field = 1.into();\n\n    // Generate public keys and aggregated key using the new function\n    let (pk1, agg_pk1) = gen_public_key_and_aggregate_key(g, sk1, old_aggk); // Player 1's public key and aggregated key\n    let (pk2, agg_pk2) = gen_public_key_and_aggregate_key(g, sk2, agg_pk1); // Player 2's public key and aggregated key\n    let (pk3, agg_pk3) = gen_public_key_and_aggregate_key(g, sk3, agg_pk2); // Player 3's public key and aggregated key\n\n    // At this point, agg_pk3 is the final aggregated public key\n    let agg_pk: Field = agg_pk3; // The final aggregated public key after all players\n\n    // Initial message (fresh card with 1 and message m)\n    let m: Field = 1234567890.into();\n    let plain: [Field; 2] = [1.into(), m]; // Initial message is [1, m]\n\n    // Player 1 encrypts the message using the aggregate public key\n    let rand1: Field = 77.into(); // Random value for Player 1\n    let ct1 = encrypt(g, agg_pk, plain, rand1);\n    // println(f\"Player 1 encryption (ct1): {ct1}\");\n\n    // Player 2 encrypts the ciphertext (ct1) using the aggregate public key\n    let rand2: Field = 88.into(); // Random value for Player 2\n    let ct2 = encrypt(g, agg_pk, ct1, rand2);\n    // println(f\"Player 2 encryption (ct2): {ct2}\");\n\n    // Player 3 encrypts the ciphertext (ct2) using the aggregate public key\n    let rand3: Field = 99.into(); // Random value for Player 3\n    let ct3 = encrypt(g, agg_pk, ct2, rand3);\n    // println(f\"Player 3 encryption (ct3): {ct3}\");\n\n    // Player 3 decrypts the ciphertext (ct3) using their secret key sk3\n    let (recovered_pk3, msg3) = decrypt(g, ct3, sk3);\n    // println(f\"Player 3 decryption (msg3): {msg3}\");\n    // println(f\"Recovered public key (Player 3): {recovered_pk3}\");\n\n    // Player 2 decrypts the ciphertext (msg3) using their secret key sk2\n    let (recovered_pk2, msg2) = decrypt(g, msg3, sk2);\n    // println(f\"Player 2 decryption (msg2): {msg2}\");\n    // println(f\"Recovered public key (Player 2): {recovered_pk2}\");\n\n    // Player 1 decrypts the ciphertext (msg2) using their secret key sk1 to get back the original message\n    let (recovered_pk1, msg1) = decrypt(g, msg2, sk1);\n    // println(f\"Player 1 decryption (msg1): {msg1}\");\n    // println(f\"Recovered public key (Player 1): {recovered_pk1}\");\n\n    assert(recovered_pk3 == pk3, \"Decrypted public key does not match original public key\");\n    assert(recovered_pk2 == pk2, \"Decrypted public key does not match original public key\");\n    assert(recovered_pk1 == pk1, \"Decrypted public key does not match original public key\");\n\n    // Verifying that the final decrypted message matches the original plaintext\n    assert(msg1[1] == m, \"Decrypted message does not match original message\");\n}\n\n#[test]\npub fn test_calculate_decrypt_component_matches_direct_decrypt_2_layered_onion_encryption_decryption() {\n    let g: Field = 3;\n    let sk1: Field = 11.into();\n    let sk2: Field = 22.into();\n\n    // Start with aggregate key = 1, then sequentially add each pk\n    let old_aggk: Field = 1.into();\n    let (_pk1, agg_pk1) = gen_public_key_and_aggregate_key(g, sk1, old_aggk);\n    let (_pk2, agg_pk) = gen_public_key_and_aggregate_key(g, sk2, agg_pk1); // Final aggregate pk = g^{sk1 + sk2}\n\n    let m: Field = 64.into();\n    let plain: [Field; 2] = [1.into(), m];\n    let rand: Field = 77.into();\n\n    let ciphertext = encrypt(g, agg_pk, plain, rand);\n    let c1 = ciphertext[0];\n    let c2 = ciphertext[1];\n\n    // Each player computes their decrypt component\n    let share1 = calculate_decrypt_component(c1, sk1); // c1^sk1\n    let share2 = calculate_decrypt_component(c1, sk2); // c1^sk2\n\n    // Combine shares: m = c2 / (share1 * share2)\n    let decrypted_msg = c2 / share1 / share2;\n    println(f\"Decryption Result: got {decrypted_msg}, expected {m}\");\n\n    // Check correctness\n    assert(decrypted_msg == m, f\"Decryption failed: got {decrypted_msg}, expected {m}\");\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/shared/src/elgamal.nr"}},"names":["main"],"brillig_names":["directive_to_radix","directive_invert"]}