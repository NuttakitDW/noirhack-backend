{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":12960822472930641334,"abi":{"parameters":[{"name":"deck","type":{"kind":"array","length":10,"type":{"kind":"array","length":2,"type":{"kind":"field"}}},"visibility":"public"},{"name":"deck_size","type":{"kind":"field"},"visibility":"public"},{"name":"card","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"decrypt_components","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"num_decrypt_components","type":{"kind":"field"},"visibility":"private"},{"name":"expected_messages","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"public"},{"name":"num_expected_messages","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"11023496693188900739":{"error_kind":"string","string":"decrypted value not in expected set"},"11518994790667008983":{"error_kind":"string","string":"card not found in deck"}}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use shared::elgamal::{calculate_decrypt_component, encrypt};\nuse shared::utils::{gen_public_key_and_aggregate_key, poseidon_hash};\n\nfn main(\n    deck: pub [[Field; 2]; 10],\n    deck_size: pub Field,\n    card: [Field; 2],\n    decrypt_components: [Field; 10],\n    num_decrypt_components: Field,\n    expected_messages: pub [Field; 10],\n    num_expected_messages: pub Field,\n    nullifier_secret: Field,\n) -> pub Field {\n    let mut occurrences = 0;\n    for i in 0..10 {\n        if i < deck_size as u32 {\n            let same0: bool = deck[i][0] == card[0];\n            let same1: bool = deck[i][1] == card[1];\n            let match_card = (same0 & same1) as u32;\n            occurrences += match_card;\n        }\n    }\n    assert(occurrences >= 1, \"card not found in deck\");\n\n    let mut m = card[1];\n    for i in 0..10 {\n        if i < num_decrypt_components as u32 {\n            m = m / decrypt_components[i];\n        }\n    }\n\n    let mut is_match = 0;\n    for i in 0..10 {\n        if i < num_expected_messages as u32 {\n            if m == expected_messages[i] {\n                is_match += 1;\n            }\n        }\n    }\n    assert(is_match >= 1, \"decrypted value not in expected set\");\n\n    poseidon_hash([nullifier_secret])\n}\n\n#[test]\nfn test_main() {\n    let g: Field = 3;\n    let sk1: Field = 22;\n    let sk2: Field = 33;\n    let msg: Field = 0x574f4c46; // \"WOLF\"\n    let rand: Field = 77;\n    let nullifier_secret: Field = 123456789;\n\n    let (_, mut agg_pk) = gen_public_key_and_aggregate_key(g, sk1, 1);\n    let (_, agg_pk_final) = gen_public_key_and_aggregate_key(g, sk2, agg_pk);\n    agg_pk = agg_pk_final;\n\n    let card = encrypt(g, agg_pk, [1, msg], rand);\n\n    let decrypt_component_1 = calculate_decrypt_component(card[0], sk1);\n    let decrypt_component_2 = calculate_decrypt_component(card[0], sk2);\n\n    let mut decrypt_components = [1; 10];\n    decrypt_components[0] = decrypt_component_1;\n    decrypt_components[1] = decrypt_component_2;\n    let num_decrypt_components: Field = 2;\n\n    let mut expected_messages = [0; 10];\n    expected_messages[0] = msg;\n    expected_messages[1] = 43;\n    expected_messages[2] = 44;\n    let num_expected_messages: Field = 3;\n\n    let dummy1: [Field; 2] = [5, 5];\n    let dummy2: [Field; 2] = [6, 6];\n\n    let mut deck = [[0; 2]; 10];\n    deck[0] = dummy1;\n    deck[1] = card;\n    deck[2] = dummy2;\n    let deck_size: Field = 3;\n\n    let nullifier_hash = main(\n        deck,\n        deck_size,\n        card,\n        decrypt_components,\n        num_decrypt_components,\n        expected_messages,\n        num_expected_messages,\n        nullifier_secret,\n    );\n\n    let expected_hash = poseidon_hash([nullifier_secret]);\n    assert(nullifier_hash == expected_hash);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/verify_card_message/src/main.nr"},"67":{"source":"use crate::algebra::pow;\nuse std::hash::poseidon2::Poseidon2;\n\npub fn gen_public_key_and_aggregate_key(\n    generator: Field,\n    sk: Field,\n    old_aggk: Field,\n) -> (Field, Field) {\n    let pk = pow(generator, sk);\n    let new_aggk = old_aggk * pk;\n    (pk, new_aggk)\n}\n\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\n#[test]\nfn test_onion_aggregation() {\n    let generator: Field = 3; // Generator value\n    let sk1: Field = 22.into(); // Player 1's secret key\n    let sk2: Field = 33.into(); // Player 2's secret key\n    let sk3: Field = 44.into(); // Player 3's secret key\n\n    let old_aggk: Field = 1.into(); // Starting aggregated key\n\n    // Player 1 generates their public key and aggregates\n    let (_, aggk1) = gen_public_key_and_aggregate_key(generator, sk1, old_aggk);\n    // println(f\"Player 1 public key: {pk1}, Aggregated key: {aggk1}\");\n\n    // Player 2 generates their public key and aggregates with the previous one\n    let (_, aggk2) = gen_public_key_and_aggregate_key(generator, sk2, aggk1);\n    // println(f\"Player 2 public key: {pk2}, Aggregated key: {aggk2}\");\n\n    // Player 3 generates their public key and aggregates with the previous one\n    let (_, aggk3) = gen_public_key_and_aggregate_key(generator, sk3, aggk2);\n    // println(f\"Player 3 public key: {pk3}, Aggregated key: {aggk3}\");\n\n    // Final aggregated key after all players\n    let expected_aggk: Field = pow(generator, sk1) * pow(generator, sk2) * pow(generator, sk3);\n    assert(aggk3 == expected_aggk, \"Final aggregated key does not match expected value.\");\n\n    // Verify the correctness of the aggregation\n    // let debug_final = f\"Final aggregated key: {aggk3}, Expected aggregated key: {expected_aggk}\";\n    // println(debug_final);\n}\n","path":"/mnt/c/Users/latta/Desktop/rust/noir/neff-shuffle/crates/shared/src/utils.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}